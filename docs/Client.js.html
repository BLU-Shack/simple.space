<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Client.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Base.html">Base</a><ul class='members'><li data-type='method'><a href="Base.html#raw">raw</a></li></ul></li><li><a href="Bot.html">Bot</a><ul class='methods'><li data-type='method'><a href="Bot.html#toString">toString</a></li></ul><ul class='members'><li data-type='method'><a href="Bot.html#approved">approved</a></li><li data-type='method'><a href="Bot.html#avatar">avatar</a></li><li data-type='method'><a href="Bot.html#certified">certified</a></li><li data-type='method'><a href="Bot.html#childFriendlyAvatar">childFriendlyAvatar</a></li><li data-type='method'><a href="Bot.html#createdAt">createdAt</a></li><li data-type='method'><a href="Bot.html#discriminator">discriminator</a></li><li data-type='method'><a href="Bot.html#fullDescription">fullDescription</a></li><li data-type='method'><a href="Bot.html#id">id</a></li><li data-type='method'><a href="Bot.html#invite">invite</a></li><li data-type='method'><a href="Bot.html#inviteNoPerms">inviteNoPerms</a></li><li data-type='method'><a href="Bot.html#owner">owner</a></li><li data-type='method'><a href="Bot.html#owners">owners</a></li><li data-type='method'><a href="Bot.html#page">page</a></li><li data-type='method'><a href="Bot.html#prefix">prefix</a></li><li data-type='method'><a href="Bot.html#raw">raw</a></li><li data-type='method'><a href="Bot.html#secondaryOwners">secondaryOwners</a></li><li data-type='method'><a href="Bot.html#serverCount">serverCount</a></li><li data-type='method'><a href="Bot.html#shards">shards</a></li><li data-type='method'><a href="Bot.html#supportCode">supportCode</a></li><li data-type='method'><a href="Bot.html#supportURL">supportURL</a></li><li data-type='method'><a href="Bot.html#tag">tag</a></li><li data-type='method'><a href="Bot.html#tags">tags</a></li><li data-type='method'><a href="Bot.html#updatedAt">updatedAt</a></li><li data-type='method'><a href="Bot.html#username">username</a></li><li data-type='method'><a href="Bot.html#vanity">vanity</a></li><li data-type='method'><a href="Bot.html#vanityURL">vanityURL</a></li><li data-type='method'><a href="Bot.html#views">views</a></li></ul></li><li><a href="Client.html">Client</a><ul class='methods'><li data-type='method'><a href="Client.html#edit">edit</a></li><li data-type='method'><a href="Client.html#fetchAllBots">fetchAllBots</a></li><li data-type='method'><a href="Client.html#fetchBot">fetchBot</a></li><li data-type='method'><a href="Client.html#fetchBotsOfUser">fetchBotsOfUser</a></li><li data-type='method'><a href="Client.html#fetchStats">fetchStats</a></li><li data-type='method'><a href="Client.html#fetchUpvotes">fetchUpvotes</a></li><li data-type='method'><a href="Client.html#fetchUser">fetchUser</a></li><li data-type='method'><a href="Client.html#postCount">postCount</a></li></ul><ul class='members'><li data-type='method'><a href="Client.html#_nextCache">_nextCache</a></li><li data-type='method'><a href="Client.html#bots">bots</a></li><li data-type='method'><a href="Client.html#endpoint">endpoint</a></li><li data-type='method'><a href="Client.html#options">options</a></li><li data-type='method'><a href="Client.html#users">users</a></li></ul></li><li><a href="FetchError.html">FetchError</a></li><li><a href="Guild.html">Guild</a><ul class='members'><li data-type='method'><a href="Guild.html#raw">raw</a></li></ul></li><li><a href="Ratelimit.html">Ratelimit</a></li><li><a href="Upvote.html">Upvote</a><ul class='methods'><li data-type='method'><a href="Upvote.html#toString">toString</a></li></ul><ul class='members'><li data-type='method'><a href="Upvote.html#raw">raw</a></li><li data-type='method'><a href="Upvote.html#timestamp">timestamp</a></li><li data-type='method'><a href="Upvote.html#user">user</a></li></ul></li><li><a href="User.html">User</a><ul class='methods'><li data-type='method'><a href="User.html#toString">toString</a></li></ul><ul class='members'><li data-type='method'><a href="User.html#avatar">avatar</a></li><li data-type='method'><a href="User.html#description">description</a></li><li data-type='method'><a href="User.html#discriminator">discriminator</a></li><li data-type='method'><a href="User.html#id">id</a></li><li data-type='method'><a href="User.html#page">page</a></li><li data-type='method'><a href="User.html#raw">raw</a></li><li data-type='method'><a href="User.html#tag">tag</a></li><li data-type='method'><a href="User.html#username">username</a></li></ul></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<div id="main">
    
    <h1 class="page-title">Client.js</h1>
    
    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* eslint-disable no-unused-vars */
const EventEmitter = require('events');
const Fetch = require('node-fetch').default; // Literally only for linting
const util = require('util'); // eslint-disable-line no-unused-vars
const { isObject, check, clientEvents: Events } = require('./util/');

const ok = /2\d\d/;

const Store = require('@ired_me/red-store');
const { Bot, Guild, User, Upvote, Stats,
	ClientOptions, FetchOptions, PostOptions, MultiFetchOptions,
	Ratelimit, FetchError, } = require('./structures/');

/**
 * Main client class for interacting to botlist.space
 * @extends {EventEmitter}
 */
class Client extends EventEmitter {
	/**
	 * @param {ClientOptions} options The options to configure.
	 */
	constructor(options = ClientOptions) {
		super();

		/**
		 * The ClientOptions.
		 * @type {ClientOptions}
		 */
		this.options = ClientOptions;

		this.edit(Object.assign(ClientOptions, options), true);

		/**
		 * The next timeout when cache is updated.
		 * @type {?NodeJS.Timeout}
		 */
		this._nextCache = null;

		/**
		 * Every bot cached, mapped by their IDs.
		 * @type {Store&lt;string, Bot>}
		 */
		this.bots = new Store();

		/**
		 * Every user cached, mapped by their IDs.
		 * **This store does not automatically cache like the others, and only caches upon a user fetch.**
		 * @type {Store&lt;string, User>}
		 */
		this.users = new Store();
	}

	async get(point, Authorization, version, ...headers) {
		const i = await Fetch(this.endpoint + version + point + headers.join(''), { headers: { Authorization } });
		if (i.status === 429) throw new Ratelimit(i.headers);
		const contents = await i.json();
		if (contents.code &amp;&amp; !ok.test(contents.code)) throw new FetchError(i, contents.message);
		return contents;
	}

	async post(point, Authorization, version, body) {
		const i = await Fetch(this.endpoint + version + point, {
			method: 'post',
			headers: { Authorization, 'Content-Type': 'application/json' },
			body: JSON.stringify(body)
		});
		if (i.status === 429) throw new Ratelimit(i);
		const contents = await i.json();
		if (contents.code &amp;&amp; !ok.test(contents.code)) throw new FetchError(i, contents.message);
		return contents;
	}

	/**
	 * The endpoint to use for interaction with botlist.space.
	 * The version number is missing; Fulfilled only when fetching/posting.
	 * @type {string}
	 */
	get endpoint() {
		return 'https://api.botlist.space/v';
	}

	async _cache() {
		if (!this.options.autoCache) return;
		const i = { cache: true };
		await this.fetchAllBots(i);
		this.emit(Events.cacheUpdate, { bots: this.bots });
		this._nextCache = setTimeout(this._cache, this.options.autoCacheInterval);
	}

	/**
	 * Edit the options of the Client.
	 * @param {ClientOptions} [options={}] The options to change.
	 * @param {boolean} [preset=false] If true, uses the default ClientOptions as a target copy. Otherwise, {@link Client#options} is used.
	 */
	edit(options = {}, preset = false) {
		if (!isObject(options)) throw new TypeError('options must be an object.');
		const toCheck = Object.assign(preset ? ClientOptions : this.options, options);
		check.edit(toCheck);

		if ((toCheck.autoCacheInterval !== this.options.autoCacheInterval) &amp;&amp; toCheck._nextCache) {
			clearInterval(this._nextCache);
			this._cache();
		} else if (toCheck.autoCache &amp;&amp; !this.options.autoCache) {
			this._cache();
		} else if (!toCheck.autoCache &amp;&amp; this.options.autoCache) {
			clearInterval(this._nextCache);
			this._nextCache = null;
		}

		// Give some properties of the ClientOptions
		FetchOptions.cache = MultiFetchOptions.cache = toCheck.cache;
		FetchOptions.version = MultiFetchOptions.version = PostOptions.version = toCheck.version;
		FetchOptions.userToken = MultiFetchOptions.userToken = PostOptions.userToken = toCheck.userToken;
		FetchOptions.botToken = MultiFetchOptions.botToken = PostOptions.botToken = toCheck.botToken;

		return this.options = toCheck;
	}

	/**
	 * Fetch the site statistics.
	 * @param {FetchOptions} [options={}] Options to pass. (Ignores cache)
	 * @returns {Promise&lt;Stats>} The statistics.
	 */
	async fetchStats(options = {}) {
		const { raw, version, userToken } = Object.assign(FetchOptions, options);
		if (!userToken) throw new ReferenceError('options.userToken must be defined.');
		if (!isObject(options)) throw new TypeError('options must be an object.');

		const contents = await this.get('/statistics', userToken, version);
		return raw ? contents : new Stats(contents);
	}

	/**
	 * Fetch all bots listed on the site.
	 * @param {MultiFetchOptions} [options={}] Options to pass.
	 * @returns {Promise&lt;Bot[] | Store&lt;string, Bot>>}
	 */
	async fetchAllBots(options = {}) {
		const { cache, mapify, raw, version, userToken, page } = Object.assign(MultiFetchOptions, options);
		if (!userToken) throw new ReferenceError('options.userToken must be defined.');
		if (typeof page !== 'number') throw new TypeError('page must be a number.');
		if (!isObject(options)) throw new TypeError('options must be an object.');

		const contents = await this.get('/bots', userToken, version, `?page=${page}`);
		if (cache) this.bots = this.bots.concat(new Store(contents.bots.map(bot => [bot.id, new Bot(bot, this)])));
		if (mapify) return cache ? this.bots : new Store(contents.bots.map(bot => [bot.id, new Bot(bot, this)]));
		else return raw ? contents : contents.bots.map(c => new Bot(c.bots, this));
	}

	/**
	 * Fetch a bot listed on the site.
	 * @param {string | FetchOptions} [id=this.options.botID] The ID of the bot to fetch. Not required if this.options.botID is set.
	 * Can be {@link FetchOptions}, uses [options.botID]({@link ClientOptions#bot}) if so
	 * @param {FetchOptions} [options={}] Options to pass.
	 * @returns {Promise&lt;Bot>} A bot object.
	 */
	async fetchBot(id = this.options.botID, options = {}) {
		if (isObject(id)) {
			options = id;
			id = this.options.botID;
		}
		const { cache, raw, version, userToken } = Object.assign(FetchOptions, options);
		if (!userToken) throw new ReferenceError('options.userToken must be defined.');

		if (typeof id === 'undefined' || id === null) throw new ReferenceError('id must be defined.');
		if (typeof id !== 'string' &amp;&amp; !isObject(id)) throw new TypeError('id must be a string.');
		if (!isObject(options)) throw new TypeError('options must be an object.');

		const contents = await this.get(`/bots/${id}`, userToken, version);
		if (cache) this.bots.set(contents.id, new Bot(contents));
		return raw ? contents : new Bot(contents);
	}

	/**
	 * Fetch a bot's upvotes from the past 24 hours.
	 * @param {string | MultiFetchOptions} [id=this.options.botID] The bot ID to fetch upvotes from.
	 * Can be {@link FetchOptions}, uses [options.botID]({@link ClientOptions#bot}) if so
	 * @param {MultiFetchOptions} [options={}] Options to pass.
	 * @returns {Promise&lt;Upvote[]>} An array of upvotes.s
	 */
	async fetchUpvotes(id = this.options.botID, options = {}) {
		if (isObject(id)) {
			options = id;
			id = this.options.botID;
		}
		const { cache, raw, version, botToken, page, mapify } = Object.assign(MultiFetchOptions, options);
		if (!botToken) throw new ReferenceError('options.botToken must be defined.');

		if (typeof id === 'undefined' || id === null) throw new ReferenceError('id must be defined.');
		if (typeof id !== 'string' &amp;&amp; !isObject(id)) throw new TypeError('id must be a string.');
		if (!isObject(options)) throw new TypeError('options must be an object.');

		const contents = await this.get(`/bots/${id}/upvotes`, botToken, version, `?page=${page}`);
		if (cache) this.users = this.users.concat(new Store(contents.upvotes.map(c => [c.user.id, new User(c.user)])));
		if (mapify) return new Store(contents.upvotes.map(c => [c.user.id, new User(c.user)]));
		else return raw ? contents : contents.upvotes.map(c => new User(c.user));
	}

	/**
	 * Fetch a user logged onto the site.
	 * @param {string} id The user ID to fetch from the API.
	 * @param {FetchOptions} [options={}] Options to pass.
	 * @returns {Promise&lt;User>} A user object.
	 */
	async fetchUser(id, options = {}) {
		const { cache, raw, version, userToken } = Object.assign(FetchOptions, options);
		if (!userToken) throw new ReferenceError('options.userToken must be defined.');
		if (typeof id === 'undefined' || id === null) throw new ReferenceError('id must be defined.');
		if (typeof id !== 'string') throw new TypeError('id must be a string.');
		if (!isObject(options)) throw new TypeError('options must be an object.');

		const contents = await this.get(`/users/${id}`, userToken, version);
		if (cache) this.users.set(contents.id, new User(contents));
		return raw ? contents : new User(contents);
	}

	/**
	 * Fetches all bots that a user owns.
	 * @param {string} id A user ID to fetch bots from.
	 * @param {MultiFetchOptions} [options={}] Options to pass.
	 * @returns {Promise&lt;Bot[]>}
	 */
	async fetchBotsOfUser(id, options = {}) {
		const { cache, raw, version, mapify, userToken, page } = Object.assign(MultiFetchOptions, options);
		if (!userToken) throw new ReferenceError('options.userToken must be defined.');
		if (typeof id === 'undefined' || id === null) throw new ReferenceError('id must be defined.');
		if (typeof id !== 'string') throw new TypeError('id must be a string.');
		if (!isObject(options)) throw new TypeError('options must be an object.');

		const contents = await this.get(`/users/${id}/bots`, userToken, version, `?page=${page}`);

		if (cache) this.bots = this.bots.concat(new Store(contents.bots.map(b => [b.id, new Bot(b)])));
		if (mapify) return new Store(contents.bots.map(b => [b.id, new Bot(b)]));
		else return raw ? contents : contents.bots.map(b => new Bot(b));
	}

	/**
	 * Post your server count to the site.
	 * @param {string | PostOptions} [id=this.options.botID] The bot ID to post server count for. Not required if a bot ID was supplied.
	 * Can be PostOptions if using the bot ID supplied from ClientOptions.
	 * @param {PostOptions} [options={}] Options to pass.
	 * @returns {object} An object.
	 */
	async postCount(id = this.options.botID, options = {}) {
		if (isObject(id)) {
			options = id;
			id = this.options.botID;
		}
		if (typeof id === 'undefined' || id === null) throw new ReferenceError('id must be defined.');
		if (typeof id !== 'string' &amp;&amp; !isObject(id)) throw new TypeError('id must be a string.');
		if (!isObject(options)) throw new TypeError('options must be an object.');
		const { version, botToken, countOrShards } = Object.assign(PostOptions, options);

		if (typeof botToken === 'undefined') throw new ReferenceError('options.botToken must be defined, or in ClientOptions.');
		if (typeof botToken !== 'string') throw new TypeError('options.botToken must be a string.');
		if (typeof countOrShards === 'undefined') throw new ReferenceError('options.countOrShards must be defined.');
		if (typeof options.countOrShards !== 'number' &amp;&amp; !Array.isArray(options.countOrShards)) throw new TypeError('options.countOrShards must be a number or array of numbers.'); // eslint-disable-line max-len

		const body = Array.isArray(options.countOrShards) ? { shards: options.countOrShards } : { server_count: options.countOrShards };
		const contents = await this.post(`/bots/${id}`, botToken, version, body);
		return contents;
	}
}

module.exports = Client;</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Mon Dec 31 2018 22:07:28 GMT-0800 (Pacific Standard Time) using the Toast theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
