<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Client.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Base.html">Base</a><ul class='members'><li data-type='method'><a href="Base.html#raw">raw</a></li></ul></li><li><a href="Bot.html">Bot</a><ul class='methods'><li data-type='method'><a href="Bot.html#toString">toString</a></li></ul><ul class='members'><li data-type='method'><a href="Bot.html#approved">approved</a></li><li data-type='method'><a href="Bot.html#avatar">avatar</a></li><li data-type='method'><a href="Bot.html#childFriendlyAvatar">childFriendlyAvatar</a></li><li data-type='method'><a href="Bot.html#createdAt">createdAt</a></li><li data-type='method'><a href="Bot.html#createdTimestamp">createdTimestamp</a></li><li data-type='method'><a href="Bot.html#discriminator">discriminator</a></li><li data-type='method'><a href="Bot.html#fullDescription">fullDescription</a></li><li data-type='method'><a href="Bot.html#id">id</a></li><li data-type='method'><a href="Bot.html#invite">invite</a></li><li data-type='method'><a href="Bot.html#inviteNoPerms">inviteNoPerms</a></li><li data-type='method'><a href="Bot.html#lastUpdateTimestamp">lastUpdateTimestamp</a></li><li data-type='method'><a href="Bot.html#owner">owner</a></li><li data-type='method'><a href="Bot.html#owners">owners</a></li><li data-type='method'><a href="Bot.html#page">page</a></li><li data-type='method'><a href="Bot.html#prefix">prefix</a></li><li data-type='method'><a href="Bot.html#raw">raw</a></li><li data-type='method'><a href="Bot.html#secondaryOwners">secondaryOwners</a></li><li data-type='method'><a href="Bot.html#serverCount">serverCount</a></li><li data-type='method'><a href="Bot.html#shards">shards</a></li><li data-type='method'><a href="Bot.html#shortDescription">shortDescription</a></li><li data-type='method'><a href="Bot.html#supportCode">supportCode</a></li><li data-type='method'><a href="Bot.html#supportURL">supportURL</a></li><li data-type='method'><a href="Bot.html#tag">tag</a></li><li data-type='method'><a href="Bot.html#tags">tags</a></li><li data-type='method'><a href="Bot.html#username">username</a></li><li data-type='method'><a href="Bot.html#vanityCode">vanityCode</a></li><li data-type='method'><a href="Bot.html#vanityURL">vanityURL</a></li><li data-type='method'><a href="Bot.html#views">views</a></li></ul></li><li><a href="Client.html">Client</a><ul class='methods'><li data-type='method'><a href="Client.html#edit">edit</a></li><li data-type='method'><a href="Client.html#fetchAllBots">fetchAllBots</a></li><li data-type='method'><a href="Client.html#fetchBot">fetchBot</a></li><li data-type='method'><a href="Client.html#fetchBots">fetchBots</a></li><li data-type='method'><a href="Client.html#fetchBotsOfUser">fetchBotsOfUser</a></li><li data-type='method'><a href="Client.html#fetchStats">fetchStats</a></li><li data-type='method'><a href="Client.html#fetchUpvotes">fetchUpvotes</a></li><li data-type='method'><a href="Client.html#fetchUser">fetchUser</a></li><li data-type='method'><a href="Client.html#postCount">postCount</a></li></ul><ul class='members'><li data-type='method'><a href="Client.html#bots">bots</a></li><li data-type='method'><a href="Client.html#endpoint">endpoint</a></li><li data-type='method'><a href="Client.html#options">options</a></li><li data-type='method'><a href="Client.html#stats">stats</a></li><li data-type='method'><a href="Client.html#users">users</a></li></ul></li><li><a href="Ratelimit.html">Ratelimit</a></li><li><a href="Stats.html">Stats</a><ul class='members'><li data-type='method'><a href="Stats.html#approvedBots">approvedBots</a></li><li data-type='method'><a href="Stats.html#botUserTotal">botUserTotal</a></li><li data-type='method'><a href="Stats.html#createdAt">createdAt</a></li><li data-type='method'><a href="Stats.html#createdTimestamp">createdTimestamp</a></li><li data-type='method'><a href="Stats.html#raw">raw</a></li><li data-type='method'><a href="Stats.html#tags">tags</a></li><li data-type='method'><a href="Stats.html#totalBots">totalBots</a></li><li data-type='method'><a href="Stats.html#unapprovedBots">unapprovedBots</a></li><li data-type='method'><a href="Stats.html#users">users</a></li></ul></li><li><a href="Upvote.html">Upvote</a><ul class='methods'><li data-type='method'><a href="Upvote.html#toString">toString</a></li></ul><ul class='members'><li data-type='method'><a href="Upvote.html#botID">botID</a></li><li data-type='method'><a href="Upvote.html#raw">raw</a></li><li data-type='method'><a href="Upvote.html#timestamp">timestamp</a></li><li data-type='method'><a href="Upvote.html#user">user</a></li></ul></li><li><a href="User.html">User</a><ul class='methods'><li data-type='method'><a href="User.html#toString">toString</a></li></ul><ul class='members'><li data-type='method'><a href="User.html#avatar">avatar</a></li><li data-type='method'><a href="User.html#description">description</a></li><li data-type='method'><a href="User.html#discriminator">discriminator</a></li><li data-type='method'><a href="User.html#id">id</a></li><li data-type='method'><a href="User.html#page">page</a></li><li data-type='method'><a href="User.html#raw">raw</a></li><li data-type='method'><a href="User.html#tag">tag</a></li><li data-type='method'><a href="User.html#username">username</a></li></ul></li></ul><h3>Externals</h3><ul><li><a href="external-Headers.html">Headers</a></li><li><a href="external-Store.html">Store</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<div id="main">
    
    <h1 class="page-title">Client.js</h1>
    
    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const Fetch = require('node-fetch').default; // Only for linting
const util = require('util'); // eslint-disable-line no-unused-vars

const isObject = obj => !Array.isArray(obj) &amp;&amp; obj === Object(obj);
const check = require('./util/check.js');

const ok = /2\d\d/;

/**
 * @external Store
 * @see {@link https://github.com/iREDMe/red-store}
 */
const Store = require('@ired_me/red-store');

const Bot = require('./structures/Bot.js');
const User = require('./structures/User.js');
const Upvote = require('./structures/Upvote.js');
const Stats = require('./structures/Stats.js');
const { Ratelimit, FetchError } = require('./structures/errors.js');
const { ClientOpts, FetchOpts, PostOpts, MultiFetchOpts } = require('./structures/options.js');

/**
 * Main client class for interacting to botlist.space
 */
class Client {
	/**
	 * @param {ClientOptions} options The options to configure.
	 */
	constructor(options = ClientOpts) {
		/**
		 * The ClientOpts.
		 * @type {ClientOptions}
		 */
		this.options = ClientOpts;

		this.edit(options, true);

		/**
		 * Every bot cached, mapped by their IDs.
		 * @type {Store&lt;string, Bot>}
		 */
		this.bots = new Store();

		/**
		 * Every user cached, mapped by their IDs.
		 * **This store does not automatically cache like the others, and only caches upon a user fetch.**
		 * @type {Store&lt;string, User>}
		 */
		this.users = new Store();

		/**
		 * An array of the latest fetched Statistics, from oldest to newest.
		 * @type {Stats[]}
		 */
		this.stats = [];
	}

	async get(point, version, headers = {}) {
		let endpoint = this.endpoint + version + point;
		endpoint += Object.entries(headers).map((e, i) => (i ? '&amp;' : '?') + e[0] + '=' + e[1]).join('');
		const i = await Fetch(endpoint);
		if (i.status === 429) throw new Ratelimit(i.headers, version + point);
		const contents = await i.json();
		if (contents.code &amp;&amp; !ok.test(contents.code)) throw new FetchError(i, contents.message);
		else return contents;
	}

	async authGet(point, version, Authorization, headers = {}) {
		let endpoint = this.endpoint + version + point;
		endpoint += Object.entries(headers).map((e, i) => (i ? '&amp;' : '?') + e[0] + '=' + e[1]).join('');
		const i = await Fetch(endpoint, {
			headers: {
				Authorization: Authorization
			}
		});
		if (i.status === 429) throw new Ratelimit(i.headers, version + point);
		const contents = await i.json();
		if (contents.code &amp;&amp; !ok.test(contents.code)) throw new FetchError(i, contents.message);
		else return contents;
	}

	async post(point, version, Authorization, body) {
		const i = await Fetch(this.endpoint + version + point, {
			method: 'post',
			headers: {
				Authorization: Authorization,
				'Content-Type': 'application/json'
			},
			body: JSON.stringify(body),
		});
		if (i.status === 429) throw new Ratelimit(i.headers, version + point);
		const contents = await i.json();
		if (contents.code &amp;&amp; !ok.test(contents.code)) throw new FetchError(i, contents.message);
		else return contents;
	}

	/**
	 * The endpoint to use for interaction with botlist.space.
	 * The version number is missing; Fulfilled only when fetching/posting.
	 * @readonly
	 * @type {string}
	 */
	get endpoint() {
		return 'https://api.botlist.space/v';
	}

	/**
	 * Edit the options of the Client.
	 * @param {ClientOptions} [options={}] The options to change.
	 * @param {boolean} [preset=false] If true, uses the default ClientOpts as a target copy. Otherwise, {@link Client#options} is used.
	 * @returns {ClientOptions}
	 */
	edit(options = {}, preset = false) {
		if (!isObject(options)) throw new TypeError('options must be an object.');
		const toCheck = Object.assign(preset ? ClientOpts : this.options, options);
		check.edit(toCheck);

		if (toCheck.statsLimit &lt; this.options.statsLimit) while (this.stats.length > toCheck.statsLimit) this.stats.shift();

		// Give some properties of the ClientOpts
		FetchOpts.cache = MultiFetchOpts.cache = toCheck.cache;
		FetchOpts.version = MultiFetchOpts.version = PostOpts.version = toCheck.version;
		FetchOpts.botToken = MultiFetchOpts.botToken = PostOpts.botToken = toCheck.botToken;

		return this.options = toCheck;
	}

	/**
	 * Fetch botlist.space statistics.
	 * @param {FetchOptions} [options={}] Opts to pass. (Ignores cache)
	 * @returns {Promise&lt;Stats>} The statistics.
	 */
	async fetchStats(options = {}) {
		const { cache, raw, version } = check.fetch(Object.assign(FetchOpts, options));
		if (!isObject(options)) throw new TypeError('options must be an object.');
		const contents = await this.get('/statistics', version);

		if (cache) this.stats.push(new Stats(contents));
		while (this.stats.length > this.options.statsLimit) this.stats.shift();
		return raw ? contents : new Stats(contents);
	}

	/**
	 * Fetch all bots listed on botlist.space.
	 * @param {MultiFetchOptions} [options={}] Opts to pass.
	 * @returns {Promise&lt;Bot[] | Store&lt;string, Bot>>}
	 * @deprecated Use {@link Client#fetchBots} instead.
	 */
	async fetchAllBots(options = {}) {
		const { cache, mapify, raw, version, page } = check.multi(Object.assign(MultiFetchOpts, options));
		if (typeof page !== 'number') throw new TypeError('page must be a number.');
		if (!isObject(options)) throw new TypeError('options must be an object.');

		const contents = await this.get('/bots', version, {
			page: page
		});
		if (cache) this.bots = this.bots.concat(new Store(contents.bots.map(bot => [bot.id, new Bot(bot, this)])));
		if (mapify) return new Store(contents.bots.map(bot => [bot.id, new Bot(bot, this)]));
		else return raw ? contents : contents.bots.map(c => new Bot(c.bots, this));
	}

	/**
	 * Fetch all bots listed on botlist.space.
	 * @param {MultiFetchOptions} [options={}] Opts to pass.
	 * @returns {Promise&lt;Bot[] | Store&lt;string, Bot>>}
	 */
	async fetchBots(options = {}) {
		const { cache, mapify, raw, version, page, reverse, sortBy } = check.multi(Object.assign(MultiFetchOpts, options));
		if (typeof page !== 'number') throw new TypeError('page must be a number.');
		if (!isObject(options)) throw new TypeError('options must be an object.');

		const contents = await this.get('/bots', version, {
			page: page,
			sortBy: sortBy,
			reverseSort: reverse,
		});
		if (cache) this.bots = this.bots.concat(new Store(contents.bots.map(bot => [bot.id, new Bot(bot, this)])));
		if (mapify) return new Store(contents.bots.map(bot => [bot.id, new Bot(bot, this)]));
		else return raw ? contents : contents.bots.map(c => new Bot(c.bots, this));
	}

	/**
	 * Fetch a bot listed on botlist.space.
	 * @param {string | FetchOptions} [id=this.options.botID] The ID of the bot to fetch. Not required if this.options.botID is set.
	 * Can be {@link FetchOptions}, uses [options.botID]({@link ClientOpts#bot}) if so
	 * @param {FetchOptions} [options={}] Opts to pass.
	 * @returns {Promise&lt;Bot>} A bot object.
	 */
	async fetchBot(id = this.options.botID, options = {}) {
		if (isObject(id)) {
			options = id;
			id = this.options.botID;
		}
		const { cache, raw, version } = check.fetch(Object.assign(FetchOpts, options));

		if (typeof id === 'undefined' || id === null) throw new ReferenceError('id must be defined.');
		if (typeof id !== 'string' &amp;&amp; !isObject(id)) throw new TypeError('id must be a string.');
		if (!isObject(options)) throw new TypeError('options must be an object.');

		const contents = await this.get(`/bots/${id}`, version);
		if (cache) this.bots.set(contents.id, new Bot(contents));
		return raw ? contents : new Bot(contents);
	}

	/**
	 * Fetch a bot's upvotes from the past month; Requires Bot Token
	 * @param {string | MultiFetchOptions} [id=this.options.botID] The bot ID to fetch upvotes from.
	 * Can be {@link FetchOptions}, uses [options.botID]({@link ClientOpts#bot}) if so
	 * @param {MultiFetchOptions} [options={}] Opts to pass.
	 * @returns {Promise&lt;Upvote[] | Store&lt;string, Upvote>>} An array of upvotes.s
	 */
	async fetchUpvotes(id = this.options.botID, options = {}) {
		if (isObject(id)) {
			options = id;
			id = this.options.botID;
		}
		const { cache, raw, version, botToken, page, mapify, } = check.multi(Object.assign(MultiFetchOpts, options));
		if (!botToken) throw new ReferenceError('options.botToken must be defined.');

		if (typeof id === 'undefined' || id === null) throw new ReferenceError('id must be defined.');
		if (typeof id !== 'string' &amp;&amp; !isObject(id)) throw new TypeError('id must be a string.');
		if (!isObject(options)) throw new TypeError('options must be an object.');

		const contents = await this.authGet(`/bots/${id}/upvotes`, version, botToken, {
			page: page,
		});
		if (cache) this.users = this.users.concat(new Store(contents.upvotes.map(c => [c.user.id, new User(c.user)])));
		if (mapify) return new Store(contents.upvotes.map(c => [c.user.id, new Upvote(c, id)]));
		else return raw ? contents : contents.upvotes.map(c => new Upvote(c, id));
	}

	/**
	 * Fetch a user logged onto botlist.space.
	 * @param {string} id The user ID to fetch from the API.
	 * @param {FetchOptions} [options={}] Opts to pass.
	 * @returns {Promise&lt;User>} A user object.
	 */
	async fetchUser(id, options = {}) {
		const { cache, raw, version } = check.fetch(Object.assign(FetchOpts, options));
		if (typeof id === 'undefined' || id === null) throw new ReferenceError('id must be defined.');
		if (typeof id !== 'string') throw new TypeError('id must be a string.');
		if (!isObject(options)) throw new TypeError('options must be an object.');

		const contents = await this.get(`/users/${id}`, version);
		if (cache) this.users.set(contents.id, new User(contents));
		return raw ? contents : new User(contents);
	}

	/**
	 * Fetches all bots that a user owns.
	 * @param {string} id A user ID to fetch bots from.
	 * @param {MultiFetchOptions} [options={}] Opts to pass.
	 * @returns {Promise&lt;Bot[]>}
	 */
	async fetchBotsOfUser(id, options = {}) {
		const { cache, raw, version, mapify, page, } = check.multi(Object.assign(MultiFetchOpts, options));
		if (typeof id === 'undefined' || id === null) throw new ReferenceError('id must be defined.');
		if (typeof id !== 'string') throw new TypeError('id must be a string.');
		if (!isObject(options)) throw new TypeError('options must be an object.');

		const contents = await this.get(`/users/${id}/bots`, version, {
			page: page,
		});
		if (cache) this.bots = this.bots.concat(new Store(contents.bots.map(b => [b.id, new Bot(b)])));
		if (mapify) return new Store(contents.bots.map(b => [b.id, new Bot(b)]));
		else return raw ? contents : contents.bots.map(b => new Bot(b));
	}

	/**
	 * Post your server count to botlist.space.
	 * @param {string | PostOptions | number | number[]} [id=this.options.botID]
	 * The bot ID to post server count for.
	 * Not required if a bot ID was supplied.
	 * Can be PostOpts if using the bot ID supplied from ClientOpts.
	 * Can also be {@link PostOpts#countOrShards} if a number/array of numbers.
	 * @param {PostOptions} [options={}]
	 * Opts to pass.
	 * Overriden by the `id` parameter if `id` is PostOpts/number/array of numbers
	 * @returns {object} An object that satisfies your low self-esteem reminding you it was successive on post.
	 */
	async postCount(id = this.options.botID, options = {}) {
		if (isObject(id)) {
			options = id;
			id = this.options.botID;
		} else if (typeof id === 'number' || Array.isArray(id)) {
			options.countOrShards = id;
			id = this.options.botID;
		}
		if (typeof id === 'undefined' || id === null) throw new ReferenceError('id must be defined.');
		if (typeof id !== 'string' &amp;&amp; !isObject(id)) throw new TypeError('id must be a string.');
		if (!isObject(options)) throw new TypeError('options must be an object.');
		const { version, botToken, countOrShards } = check.post(Object.assign(PostOpts, options));

		if (typeof botToken === 'undefined') throw new ReferenceError('options.botToken must be defined, or in ClientOpts.');
		if (typeof botToken !== 'string') throw new TypeError('options.botToken must be a string.');
		if (typeof countOrShards === 'undefined') throw new ReferenceError('options.countOrShards must be defined.');
		if (typeof options.countOrShards !== 'number' &amp;&amp; !Array.isArray(options.countOrShards)) throw new TypeError('options.countOrShards must be a number or array of numbers.'); // eslint-disable-line max-len

		const body = Array.isArray(options.countOrShards) ? { shards: options.countOrShards } : { server_count: options.countOrShards };
		const contents = await this.post(`/bots/${id}`, version, botToken, body);
		return contents;
	}
}

Client.prototype.fetchAllBots = util.deprecate(Client.prototype.fetchAllBots, 'Client#fetchAllBots - Deprecated; Use Client#fetchBots instead.');

module.exports = Client;</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue Feb 05 2019 19:25:39 GMT-0800 (Pacific Standard Time) using the Toast theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
